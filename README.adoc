= Eclipse JNoSQL databases
:toc: auto

The Eclipse JNoSQL Database API is a collection of implementations from the https://github.com/eclipse-ee4j/nosql[Jakarta NoSQL] specification.

== ArangoDB

image::https://jnosql.github.io/img/logos/ArangoDB.png[Arangodb Project,align="center"width=25%,height=25%]

https://www.arangodb.com/[ArangoDB] is a native multi-model database with flexible data models for documents, graphs, and key-values.
Build high performance applications using a convenient SQL-like query language or JavaScript extensions.

This API offers support for **Document** and **Key-Value** types.
The Graph is possible through Apache TinkerPop.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-arangodb</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```ArangoDBConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Arango Properties"]
|===
|Configuration property |Description

|`jnosql.arangodb.host`
|The database host, where you need to put the port split by colons. E.g.: jnosql.jnosql.arangodb.host=localhost:8529

|`jnosql.arangodb.user`
|The user's userID.

|`jnosql.arangodb.password`
|The user's password

|`jnosql.arangodb.timeout`
|The connection and request timeout in milliseconds.

|`jnosql.arangodb.chunk.size`
|The chunk size when Protocol is used.

|`jnosql.arangodb.userSsl`
|The true SSL will be used when connecting to an ArangoDB server.

|`jnosql.arangodb.load.balancing.strategy`
|The com.arangodb.entity.LoadBalancingStrategy as String.

|`jnosql.arangodb.protocol`
|The com.arangodb.Protocol as String

|`jnosql.arangodb.connections.max`
|The maximum number of connections the built-in connection pool will open per host.

|`jnosql.arangodb.acquire.host.list`
|Set hosts split by comma
|===

This is an example using ArangoDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.arangodb.communication.ArangoDBDocumentConfiguration
jnosql.document.database=<DATABASE>
jnosql.arangodb.host=localhost:8529
----

This is an example using ArangoDB's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.arangodb.communication.ArangoDBKeyValueConfiguration
jnosql.keyvalue.database=<DATABASE>
jnosql.arangodb.host=localhost:8529
----

The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<ArangoDBDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<ArangoDBDocumentManager> {

    @Produces
    public ArangoDBDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        ArangoDBDocumentConfiguration configuration = new ArangoDBDocumentConfiguration();
        ArangoDBDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Repository

The ```ArangoDBRepository``` interface is an extension of the Repository interface that allows execution of AQL via the ```@AQL``` annotation. Also, it's possible to combine with ```@Param``` annotation to execute parameterized AQL queries:

[source,java]
----
@Repository
interface PersonRepository extends ArangoDBRepository<Person, String> {

    @AQL("FOR p IN Person RETURN p")
    List<Person> findAll();

    @AQL("FOR p IN Person FILTER p.name = @name RETURN p")
    List<Person> findByName(@Param("name") String name);
}
----

=== @AQL

The ```@AQL``` annotation is a mapping annotation that allows to define dynamic queries following link:https://www.arangodb.com/docs/stable/aql/[ArangoDB Query Languange] on ```ArangoDBRepository```.

[source,java]
----
interface CarRepository extends ArangoDBRepository<Car, String> {

        @AQL("FOR c IN Car RETURN c")
        List<Car> findAll();

}
----

=== @Param

For parameterized queries, use the ```@Param``` annotation for binding the target argument to the parameter informing the named parameter like the below example:

[source,java]
----

interface OrderRepository extends ArangoDBRepository<Order, String> {

        @AQL("FOR o IN Order FILTER o.customer = @customer RETURN o")
        List<Order> findByCustomer(@Param("customer") String customer);

}
----


=== Template

The ```ArangoDBTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows using both synchronous and asynchronous AQL.

[source,java]
----
@Inject
private ArangoDBTemplate template;
...
List<Person> people = template.aql("FOR p IN Person FILTER p.name = @name RETURN p", params);
----

=== How @Id Works in ArangoDB

In ArangoDB, the `_id` field is a read-only, auto-generated value created by the database. It is a combination of the collection name and the `_key` field in the format `<collection-name>/<_key>`. The `_id` is automatically managed by the database, meaning any value set by the client will be ignored.

To map the `_id` and `_key` fields in your entities, you can use the `@Id` annotation and specify the `_key` field explicitly. This allows you to manage the `_key` value directly in your code while letting the database handle the `_id` generation.

For example:

[source,java]
----
@Entity
public class User {

    @Id("_key")
    private String key;

    private String name;

}
----

In this example, the `_key` field is annotated with `@Id("_key")`, allowing the application to control the `_key` value while the database auto-generates the corresponding `_id` field. This approach is useful for scenarios where you need to set or manage the `_key` value explicitly in your application logic.


== Cassandra

image::https://jnosql.github.io/img/logos/cassandra.png[Apache Cassandra,align="center"width=25%,height=25%]

https://cassandra.apache.org/[Apache Cassandra] is a free and open-source distributed database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-cassandra</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```CassandraConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Cassandra"]
|===
|Configuration property |Description

|`jnosql.cassandra.user`
|The user's userID.

|`jnosql.cassandra.password`
|The user's password

|`jnosql.cassandra.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.cassandra.host.1=localhost

|`jnosql.cassandra.name`
|The name of the application using the created session.

|`jnosql.cassandra.port`
|The cassandra's port

|`jnosql.cassandra.query`
|The Cassandra CQL to execute when the configuration starts. It uses as a prefix. E.g.: jnosql.cassandra.query.1=<CQL>

|`jnosql.cassandra.data.center`
|The datacenter that is considered "local" by the load balancing policy.
|===

This is an example using Cassandra with MicroProfile Config.

[source,properties]
----
jnosql.column.provider=org.eclipse.jnosql.databases.cassandra.communication.CassandraConfiguration
jnosql.column.database=developers
jnosql.cassandra.query-1=<CQL-QUERY>
jnosql.cassandra.query.2=<CQL-QUERY-2>
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<CassandraColumnManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<CassandraColumnManager> {

    @Produces
    public CassandraColumnManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        CassandraConfiguration configuration = new CassandraConfiguration();
        CassandraColumnManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```CassandraRepository``` interface is an extension of the ```Repository``` interface that allows execution of CQL and Consistency Level via the ```@CQL``` annotation.

[source,java]
----
@Repository
interface PersonRepository extends CassandraRepository<Person, String> {

    @CQL("select * from Person")
    List<Person> findAll();

    @CQL("select * from Person where name = ?")
    List<Person> findByName(String name);

    @CQL("select * from Person where age = :age")
    List<Person> findByAge(@Param("age") Integer age);
 }
----


=== UDT at Column annotation

The ```@Column``` contains a UDT attribute for mapping annotation that allows defining a field to be stored as a user-defined type in Cassandra.

[source,java]
----
@Entity
public class Person {

    @Id("name")
    private String name;

    @Column
    private Integer age;

    @Column(udt="address")
    private Address home;
 }
----

=== Converts

* TimestampConverter: That converts to/from java.util.Date
* LocalDateConverter: That converts to/from com.datastax.driver.core.LocalDate

[source,java]
----
    @Column
    @Convert(value = TimestampConverter.class)
    private LocalDateTime localDateTime;

    @Column
    @Convert(value = LocalDateConverter.class)
    private Calendar calendar;
----

=== Template

The ```CassandraTemplate``` interface is a specialization of ```ColumnTemplate``` interface that allows using CQL.

[source,java]
----
@Inject
CassandraTemplate template;
...
template.save(person, ConsistencyLevel.ONE);
----

== Couchbase

image::https://jnosql.github.io/img/logos/couchbase.svg[Couchbase Project,align="center"width=25%,height=25%]

The https://www.couchbase.com/[Couchbase] driver provides an API integration between Java and the database through a standard communication level.

This driver has support for two NoSQL API types: *Document* and *Key-Value*.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-couchbase</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```CouchbaseConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Couchbase"]
|===
|Configuration property |Description


|`jnosql.couchbase.host`
|The host at the database.

|`jnosql.couchbase.user`
|The user's userID.

|`jnosql.couchbase.password`
|The user's password

|`jnosql.couchbase.scope`
|The scope to use at couchbase otherwise, it will use the default.

|`jnosql.couchbase.collections`
|couchbase collection split by a comma. At the start-up of a CouchbaseConfiguration, there is this option to check if these collections exist; if not, it will create using the default settings.

|`jnosql.couchbase.collection`
|A default couchbase collection. When it is not defined the default value comes from Bucket.

|`jnosql.couchbase.index`
|A couchbase collection index. At the start-up of a {@link CouchbaseConfiguration}, it will read this property to check if the index does exist, if not it will create combined by scope and the database.


|===

This is an example using Couchbase's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.couchbase.communication.CouchbaseDocumentConfiguration
jnosql.document.database=heroes
jnosql.couchbase.host.1=localhost
jnosql.couchbase.user=root
jnosql.couchbase.password=123456
----

This is an example using Couchbase's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.database=heroes
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.couchbase.communication.CouchbaseKeyValueConfiguration
jnosql.couchbase.host.1=localhost
jnosql.couchbase.user=root
jnosql.couchbase.password=123456
----

The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<CouchbaseDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<CouchbaseDocumentManager> {

    @Produces
    public CouchbaseDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        CouchbaseDocumentConfiguration configuration = new CouchbaseDocumentConfiguration();
        CouchbaseDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```CouchbaseRepository``` interface is an extension of the ```Repository``` interface that allows execution of N1QL via the ```@N1QL``` annotation.


[source,java]
----
@Repository
interface PersonRepository extends CouchbaseRepository<Person, String> {

@N1QL("select * from Person")
List<Person> findAll();

@N1QL("select * from Person where name = $name")
List<Person> findByName(@Param("name") String name);

}
----


=== Template

The ```CouchbaseTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows using N1QL on both synchronous and asynchronous.

[source,java]
----
List<Person> people = template.n1qlQuery("select * from Person where name = $name", params);
----

== CouchDB

image::https://www.jnosql.org/img/logos/couchdb.png[CouchDB,align="center"width=25%,height=25%]

The https://couchdb.apache.org/[CouchDB] driver provides an API integration between Java and the database through a standard communication level.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-couchdb</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```CouchDBConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="CouchDB"]
|===
|Configuration property |Description

|`jnosql.couchdb.port`
|The port connection to a client connect. The default value is "5984"

|`jnosql.couchdb.max.connections`
|The max of connection that the couchdb client have. The default value is "20"

|`jnosql.couchdb.connection.timeout`
|The timeout in milliseconds used when requesting a connection. The default value is "1000".

|`jnosql.couchdb.socket.timeout`
|The socket timeout in milliseconds, which is the timeout for waiting for data or, put differently, a maximum period inactivity between two consecutive data packets). The default value is "10000".

|`jnosql.couchdb.max.object.size.bytes`
|The current maximum response body size that will be cached. The value is "8192".

|`jnosql.couchdb.max.cache.entries`
|The maximum number of cache entries the cache will retain. The default value is "1000".

|`jnosql.couchdb.host`
|The host at the database.

|`jnosql.couchdb.username`
|The user's userID.

|`jnosql.couchdb.password`
|The user's password

|`jnosql.couchdb.enable.ssl`
|If the request use a https or a http.

|`jnosql.couchdb.compression`
|Determines whether compressed entities should be decompressed automatically.

|===

This is an example using CouchDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.couchdb.communication.CouchDBDocumentConfiguration
jnosql.document.database=heroes
jnosql.couchdb.host=localhost
jnosql.couchdb.username=admin
jnosql.couchdb.password=password
----

== DynamoDB

image::https://user-images.githubusercontent.com/6509926/70553550-f033b980-1b40-11ea-9192-759b3b1053b3.png[Redis Project,align="center" width=50%,height=50%]

https://aws.amazon.com/dynamodb/[Amazon DynamoDB] is a fully managed, serverless, key-value and document NoSQL database designed to run high-performance applications at any scale. DynamoDB offers built-in security, continuous backups, automated multi-Region replication, in-memory caching, and data import and export tools.

This driver has support for two NoSQL API types: *Key-Value* and *Document*.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-dynamodb</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```DynamoDBConfigurations``` class to programmatically establish the credentials.

Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="DynamoDB"]
|===
|Configuration property |Description

|`jnosql.dynamodb.endpoint`
|DynamoDB’s URL

|`jnosql.dynamodb.region`
|Configure the region with which the application should communicate.

|`jnosql.dynamodb.profile`
| Define the name of the profile that should be used by this credentials provider.

|`jnosql.dynamodb.awsaccesskey`
|The AWS access key, used to identify the user interacting with AWS.

|`jnosql.dynamodb.secretaccess`
|The AWS secret access key, used to authenticate the user interacting with AWS.

|===

=== Using the Key-value API

This is an example using DynamoDB's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.dynamodb.communication.DynamoDBKeyValueConfiguration
jnosql.keyvalue.database=heroes
----

=== Using the Document API

The DynamoDB's Document API implementation follows the *SINGLE TABLE* strategy, it means, the table will store multiple entity types. To satisfy this strategy, the implementation assumes that the target table will have a composed primary key:

- The `entityType` field as the partitioning key;
- The `id` field as the sort key;

To customize the partitioning key field name, you can define the following configuration

[source,properties]
----
jnosql.dynamodb.entity.pk=entityType
----

By default, the implementation doesn't create the table on-the-fly, letting this requirement for the users. If you prefer, the implementation is able to create the table on-the-fly as well. To activate this capability you should define explicitly the following configuration:

[source,properties]
----
jnosql.dynamodb.create.tables=true
----

The table will be created with the composed primary key mentioned previously.

Here's an example using DynamoDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.dynamodb.communication.DynamoDBDocumentConfiguration
jnosql.document.database=heroes
----

The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<DynamoDBDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<DynamoDBDocumentManager> {

    @Produces
    public DynamoDBDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        DynamoDBDocumentConfiguration configuration = new DynamoDBDocumentConfiguration();
        DynamoDBDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Repository

The ```DynamoDBRepository``` interface is an extension of the ```Repository``` interface that allows execution of PartiQL via the ```@PartiQL``` annotation.

WARNING: DynamoDB supports a limited subset of
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ql-reference.html[PartiQL].

NOTE: This implementation doesn't provide pagination on the queries.

[source,java]
----
@Repository
interface PersonRepository extends DynamoDBRepository<Person, String> {

@PartiQL("select * from Person")
List<Person> findAll();

@PartiQL("select * from Person where name = ?")
List<Person> findByName(@Param("") String name);

}
----


=== Template

The ```DynamoDBTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows using PartiQL queries.

WARNING: DynamoDB supports a limited subset of
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ql-reference.html[PartiQL].

NOTE: This implementation doesn't provide pagination on the queries.

[source,java]
----
List<Person> people = template.partiQL("select * from Person where name = ? ", params);
----

== Elasticsearch

image::https://jnosql.github.io/img/logos/elastic.svg[Elasticsearch Project,align="center"width=25%,height=25%]

https://www.elastic.co/[Elasticsearch] is a search engine based on Lucene.
It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents.
Elasticsearch is developed in Java and is released as open source under the terms of the Apache License.
Elasticsearch is the most popular enterprise search engine followed by Apache Solr, also based on Lucene.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-elasticsearch</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```ElasticsearchConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Elasticsearch"]
|===
|Configuration property |Description

|`jnosql.elasticsearch.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.elasticsearch.host.1=172.17.0.2:1234

|`jnosql.elasticsearch.user`
|The user's userID.

|`jnosql.elasticsearch.password`
|The user's password

|===

This is an example using Elasticsearch's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.elasticsearch.communication.ElasticsearchDocumentConfiguration
jnosql.document.database=developers
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<ElasticsearchDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<ElasticsearchDocumentManager> {

    @Produces
    public ElasticsearchDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        ElasticsearchDocumentConfiguration configuration = new ElasticsearchDocumentConfiguration();
        ElasticsearchDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Template

The ```ElasticsearchTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows using a search engine on both synchronous and asynchronous.

[source,java]
----
@Inject
ElasticsearchTemplate template;
...

QueryBuilder queryBuilder = boolQuery().filter(termQuery("name", "Ada"));
List<Person> people = template.search(queryBuilder, "Person");
----

== Hazelcast

image::https://jnosql.github.io/img/logos/hazelcast.svg[Hazelcast Project,align="center" width=25%,height=25%]

https://hazelcast.com/[Hazelcast] is an open source in-memory data grid based on Java.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-hazelcast</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```HazelcastConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Hazelcast"]
|===
|Configuration property |Description

|`jnosql.hazelcast.instance.name`
|The instance name uniquely identifying the hazelcast instance created by this configuration. This name is used in different scenarios, such as identifying the hazelcast instance when running multiple instances in the same JVM.

|`jnosql.hazelcast.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.hazelcast.host.1=localhost

|`jnosql.hazelcast.port`
|The database port

|`jnosql.hazelcast.port.count`
|The maximum number of ports allowed to use.

|`jnosql.hazelcast.port.auto.increment`
|Sets if a Hazelcast member is allowed to find a free port by incrementing the port number when it encounters an occupied port.

|`jnosql.hazelcast.multicast.enable`
|Enables or disables the multicast discovery mechanism

|`jnosql.hazelcast.tcp.ip.join`
|Enables or disables the Tcp/Ip join mechanism.

|===

This is an example using Hazelcast's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.hazelcast.communication.HazelcastKeyValueConfiguration
jnosql.keyvalue.database=heroes
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<HazelcastBucketManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<HazelcastBucketManager> {

    @Produces
    public HazelcastBucketManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        HazelcastKeyValueConfiguration configuration = new HazelcastKeyValueConfiguration();
        HazelcastBucketManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Repository

[source,java]
----
@Repository
interface PersonRepository extends HazelcastRepository<Person, String> {

        @Query("active")
        List<Person> findActive();

        @Query("name = :name AND age = :age")
        Set<Person> findByAgeAndInteger(@Param("name") String name, @Param("age") Integer age);
    }
----

=== Template

The ```HazelcastTemplate``` interface is a specialization of the ```KeyValueTemplate``` interface that allows execution of a Hazelcast query.

[source,java]
----
Collection<Person> people = template.query("active");
Collection<Person> people2 = template.query("age = :age", singletonMap("age", 10));
Collection<Person> people3 = template.query(Predicates.equal("name",  "Poliana"));
----

== HBase

image::https://jnosql.github.io/img/logos/hbase.png[Hbase Project,align="center" width=25%,height=25%]

https://hbase.apache.org/[HBase] is an open source, non-relational, distributed database modeled after Google's BigTable and is written in Java.

This driver provides support for the *Column Family* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-hbase</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```HbaseConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="HBase"]
|===
|Configuration property |Description

|`jnosql.hbase.family`
|The Column family prefixes. E.g.: jnosql.hbase.family.1=<FAMILY>

|===

This is an example using HBase's *Column Family* NoSQL API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.hbase.communication.HBaseColumnConfiguration
jnosql.column.database=heroes
----

== Infinispan

image::https://jnosql.github.io/img/logos/infinispan.svg[Infinista Project,align="center" width=25%,height=25%]

https://infinispan.org/[Infinispan] is a distributed in-memory key/value data store with optional schema, available under the Apache License 2.0.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-infinispan</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```InfinispanConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Infinispan"]
|===
|Configuration property |Description

|`jnosql.infinispan.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.infinispan.host.1=HOST

|`jnosql.infinispan.config`
|The Infinispan configuration path. E.g.: jnosql.infinispan.config=infinispan.xml

|===

This is an example using Infinispan's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.infinispan.communication.InfinispanKeyValueConfiguration
jnosql.keyvalue.database=heroes
jnosql.infinispan.config=infinispan.xml
----

== Memcached

image::https://www.jnosql.org/img/logos/memcached.png[Memcached Project,align="center" width=25%,height=25%]

https://memcached.org/[Memcached] is a general-purpose distributed memory caching system.
It is often used to speed up dynamic database-driven websites by caching data and objects in RAM to reduce the number of times an external data source (such as a database or API) must be read.
Memcached is free and open-source software, licensed under the Revised BSD license.
Memcached runs on Unix-like operating systems (at least Linux and OS X) and on Microsoft Windows.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-memcached</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```MemcachedConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Memcached"]
|===
|Configuration property |Description

|`jnosql.memcached.daemon`
|The daemon state of the IO thread (defaults to true).

|`jnosql.memcached.reconnect.delay`
|The maximum reconnect delay

|`jnosql.memcached.protocol`
|The protocol type  net.spy.memcached.ConnectionFactoryBuilder.Protocol

|`jnosql.memcached.locator`
|The locator type net.spy.memcached.ConnectionFactoryBuilder.Locator

|`jnosql.memcached.auth.wait.time`
|Custom wait time for the authentication on connect/reconnect.

|`jnosql.memcached.max.block.time`
|The maximum amount of time (in milliseconds) a client is willing to wait for space to become available in an output queue.

|`jnosql.memcached.timeout`
|The default operation timeout in milliseconds.

|`jnosql.memcached.read.buffer.size`
|The read buffer size.

|`jnosql.memcached.should.optimize`
|The default operation optimization is not desirable.

|`jnosql.memcached.timeout.threshold`
|The maximum timeout exception threshold.

|`jnosql.memcached.nagle.algorithm`
|Enable the Nagle algorithm.

|`jnosql.memcached.user`
|The user's userID

|`jnosql.memcached.password`
|The user's password.

|`jnosql.memcached.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.memcached.host.1=localhost:11211

|===

This is an example using Memcached's Document API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.memcached.communication.MemcachedKeyValueConfiguration
jnosql.keyvalue.database=heroes
jnosql.memcached.host.1=localhost:11211
----

== MongoDB

image::https://jnosql.github.io/img/logos/mongodb.png[MongoDB Project,align="center" width=25%,height=25%]

https://www.mongodb.com/[MongoDB] is a free and open-source cross-platform document-oriented database program.
Classified as a NoSQL database program, MongoDB uses JSON-like documents with schemas.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-mongodb</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```MongoDBDocumentConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="MongoDB"]
|===
|Configuration property |Description

|`jnosql.mongodb.host`
|The database host as prefix. E.g.: mongodb.host.1=localhost:27017

|`jnosql.mongodb.user`
|The user's userID.

|`jnosql.mongodb.url`
|MongoDB's connection string

|`jnosql.mongodb.password`
|The user's password

|`jnosql.mongodb.authentication.source`
|The source where the user is defined.

|`jnosql.mongodb.authentication.mechanism`
|Authentication mechanisms com.mongodb.AuthenticationMechanism

|===

This is an example using Mongodb's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.database=olympus
jnosql.mongodb.host=localhost:27017
jnosql.document.provider=org.eclipse.jnosql.databases.mongodb.communication.MongoDBDocumentConfiguration
----

The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<MongoDBDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<MongoDBDocumentManager> {

    @Produces
    public MongoDBDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        MongoDBDocumentConfiguration configuration = new MongoDBDocumentConfiguration();
        MongoDBDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Converter

In this extension, you have the option to convert to/from the MongoDB ```ObjectID```.

[source,java]
----
@Entity
public class Music {

    @Id
    @Convert(ObjectIdConverter.class)
    private String id;

}
----

=== Template

The ```MongoDBTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows MongoDB particular behavior such as delete and select elements using a `Bson` implementation and aggreate query.


[source,java]
----
@Inject
MongoDBTemplate template;
...

Bson filter = eq("name", "Poliana");
Stream<Person> stream = template.select(Person.class , filter);
----

== Oracle NoSQL

image::https://www.jnosql.org/img/logos/oracle.png[Oracle NoSQL Project,align="center"width=25%,height=25%]

https://www.oracle.com/database/nosql/technologies/nosql/[Oracle NoSQL Database] is a versatile multi-model database offering flexible data models for documents, graphs, and key-value pairs. It empowers developers to build high-performance applications using a user-friendly SQL-like query language or JavaScript extensions.

This API provides support for *Document* and *Key-Value* data types.

=== Installation

You can include Oracle NoSQL as a dependency using either Maven or Gradle:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-oracle-nosql</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

The API offers the `OracleNoSQLConfigurations` class to programmatically set up credentials. It also supports configuration via the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Oracle NoSQL Properties"]
|===
| Property Name | Description

| `jnosql.oracle.nosql.host` | Hostname or IP address of the Oracle NoSQL database server.

| `jnosql.oracle.nosql.user` | Username for Oracle NoSQL database authentication.

| `jnosql.oracle.nosql.password` | Password for Oracle NoSQL database authentication.

| `jnosql.oracle.nosql.table.read.limit` | Desired throughput of read operations when creating tables with Eclipse JNoSQL.

| `jnosql.oracle.nosql.table.write.limit` | Desired throughput of write operations when creating tables with Eclipse JNoSQL.

| `jnosql.oracle.nosql.table.storage.gb` | Maximum storage in gigabytes for tables created with Eclipse JNoSQL.

| `jnosql.oracle.nosql.table.wait.millis` | Total waiting time in milliseconds when creating a table.

| `jnosql.oracle.nosql.table.delay.millis` | Time between polling attempts in milliseconds when creating a table.

| `jnosql.oracle.nosql.tenant.id` | Tenant ID for Oracle NoSQL database in a Cloud deployment.

| `jnosql.oracle.nosql.fingerprint` | Fingerprint for authentication with Oracle NoSQL database in a Cloud deployment.

| `jnosql.oracle.nosql.private.key` | Private key for authentication with Oracle NoSQL database in a Cloud deployment.

| `jnosql.oracle.nosql.compartment` | Compartment name in Oracle Cloud Infrastructure.

| `jnosql.oracle.nosql.namespace` | Namespace name in Oracle NoSQL on-premises.

| `jnosql.oracle.nosql.profile.name` | Specifies the profile name used to load session token in Oracle NoSQL cloud.

| `jnosql.oracle.nosql.config.file` | Specifies the path of configuration file used to load session token in Oracle NoSQL cloud.

| `jnosql.oracle.nosql.deployment` | Specifies the deployment type for Oracle NoSQL database. You can choose from the following options:

- `ON_PREMISES`: Represents an on-premises deployment where software solutions are deployed and managed within an organization's physical premises or data centers.

- `CLOUD_API_KEY`: Represents a cloud deployment using API key for authentication and authorization.

- `CLOUD_INSTANCE_PRINCIPAL`: Represents a cloud deployment using instance principal for authentication and authorization.

- `CLOUD_RESOURCE_PRINCIPAL`: Represents a cloud deployment using resource principal for authentication and authorization.

- `CLOUD_INSTANCE_OBO_USER`: Represents a cloud deployment using instance principal for delegation with an OBO token.

- `CLOUD_SECURITY_TOKEN`: Represents a "Cloud" deployment using resource principal for delegation with an OBO token.
|===

Below are examples using Oracle NoSQL's Document API and Key-Value API with MicroProfile Config.

**Document API Example:**

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.oracle.communication.OracleDocumentConfiguration
jnosql.document.database=library
jnosql.oracle.nosql.host=http://localhost:8080
----

**Key-Value API Example:**

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.oracle.communication.OracleNoSQLKeyValueConfiguration
jnosql.keyvalue.database=library
jnosql.oracle.nosql.host=http://localhost:8080
----

Although these are the default configuration settings, you have the option to configure them programmatically. Create a class that implements `Supplier<OracleNoSQLDocumentManager>`, annotate it with `@Alternative`, and set the priority using `@Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<OracleNoSQLDocumentManager> {

    @Produces
    public OracleNoSQLDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        OracleDocumentConfiguration configuration = new OracleDocumentConfiguration();
        OracleDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Repository

The `OracleNoSQLRepository` interface extends the Repository interface and allows executing SQL queries using the `@SQL` annotation. You can also combine it with the `@Param` annotation for parameterized SQL queries:

[source,java]
----
@Repository
interface PersonRepository extends OracleNoSQLRepository<Person, String> {

    @SQL("select * from Person")
    List<Person> findAll();

    @SQL("select * from Person where name = ?")
    List<Person> findByName(@Param("") String name);
}
----


=== Template

The `OracleNoSQLTemplate` interface, an extension of the `DocumentTemplate`, enables synchronous SQL operations.

[source,java]
----
@Inject
private OracleNoSQLTemplate template;
...
List<Person> people = template.sql("select * from people where people.content.name =?", "Ada");
----


== OrientDB

image::https://jnosql.github.io/img/logos/orientdb.png[Orient Project,align="center" width=25%,height=25%]

https://orientdb.org/[OrientDB] is an open source NoSQL database management system written in Java.
It is a multi-model database, supporting graph, document, key/value, and object models, but the relationships are managed as in graph databases with direct connections between records.
It supports schema-less, schema-full and schema-mixed modes.
It has a strong security profiling system based on users and roles and supports querying with Gremlin along with SQL extended for graph traversal.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-orientdb</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```OrientDBDocumentConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="OrientDB"]
|===
|Configuration property |Description

|`jnosql.orientdb.host`
|The database host

|`jnosql.orientdb.user`
|The user's userID.

|`jnosql.orientdb.password`
|The user's password

|`jnosql.orientdb.storage.type`
|The storage type com.orientechnologies.orient.core.db.ODatabaseType

|===

This is an example using OrientDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.orientdb.communication.OrientDBDocumentConfiguration
jnosql.document.database=heroes
jnosql.orientdb.host=localhost:27017
jnosql.orientdb.user=root
jnosql.orientdb.password=rootpwd
jnosql.orientdb.storageType=plocal
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<OrientDBDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<OrientDBDocumentManager> {

    @Produces
    public OrientDBDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        OrientDBDocumentConfiguration configuration = new OrientDBDocumentConfiguration();
        OrientDBDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```OrientDBCrudRepository``` interface  is an extension of the ```Repository``` interface that allows execution of a SQL Query via the ```@SQL``` annotation.

[source,java]
----
@Repository
    interface PersonRepository extends OrientDBCrudRepository<Person, String> {

        @SQL("select * from Person")
        List<Person> findAll();

        @SQL("select * from Person where name = ?")
        List<Person> findByName(String name);

        @SQL("select * from Person where age = :age")
        List<Person> findByAge(@Param("age") Integer age);
    }
----

=== Template

The ```OrientDBTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows execution of a SQL query and live query on both synchronous and asynchronous.

[source,java]
----
@Inject
OrientDBTemplate template;
...

Stream<Person> stream = template.sql("select * from Person where name = ?", "Ada");
template.live("select from Person where name = ?", callBack, "Ada");
----

== RavenDB

image::https://www.jnosql.org/img/logos/ravendb.png[RavenDB Project,align="center",align="center" width=50%,height=50%]

https://ravendb.net/[RavenDB] is a fully Transactional Open Source NoSQL Document Database.
Easy to use, rapidly scalable, offers high availability, and takes your Business into the Next Generation of Data Performance.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-ravendb</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```RavenDBConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="RavenDB"]
|===
|Configuration property |Description

|`jnosql.ravendb.host`
|The database host

|===

This is an example using RavenDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.ravendb.communication.RavenDBDocumentConfiguration
jnosql.document.database=heroes
----


== Redis

image::https://jnosql.github.io/img/logos/redis.png[Redis Project,align="center" width=25%,height=25%]

https://redis.com/[Redis] is a software project that implements data structure servers.
It is open-source, networked, in-memory, and stores keys with optional durability.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-redis</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This is an example using Redis's Key-Value API with MicroProfile Config.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.redis.communication.RedisConfiguration
jnosql.keyvalue.database=heroes
----

This API provides enum classes to programmatically establish the credentials as:

- link:README.adoc#_single_node_configuration[`RedisConfigurations`] for single node configuration
+
[source,properties]
----
# Single Node Configuration

# by default the host is localhost
jnosql.redis.host=localhost
# by default the port is 6379
jnosql.redis.port=6379
# if you have user
jnosql.redis.user=youruser
# if you have password
jnosql.redis.password=yourpassword
----

- link:README.adoc#_redis_sentinel_configuration[`RedisSentinelConfigurations`] for sentinel configuration
+
[source,properties]
----
# Sentinel Configuration
jnosql.redis.sentinel.hosts=host1:26379,host2:26379

jnosql.redis.sentinel.master.name=masterName
jnosql.redis.sentinel.master.user=masterUser
jnosql.redis.sentinel.master.password=masterPassword
#jnosql.redis.sentinel.master.ssl=false
#jnosql.redis.sentinel.master.timeout=2000
#jnosql.redis.sentinel.master.connection.timeout=2000
#jnosql.redis.sentinel.master.socket.timeout=2000

jnosql.redis.sentinel.slave.user=slaveUser
jnosql.redis.sentinel.slave.password=slavePassword
#jnosql.redis.sentinel.slave.ssl=false
#jnosql.redis.sentinel.slave.timeout=2000
#jnosql.redis.sentinel.slave.connection.timeout=2000
#jnosql.redis.sentinel.slave.socket.timeout=2000
----

- link:README.adoc#_redis_sentinel_configuration[`RedisClusterConfigurations`] for cluster configuration
+
[source,properties]
----
# Cluster Configuration

jnosql.redis.cluster.hosts=host1:6379,host2:6379
jnosql.redis.cluster.user=clusterUser
jnosql.redis.cluster.password=clusterPassword
jnosql.redis.cluster.client.name=clusterClientName
jnosql.redis.cluster.max.attempts=5
jnosql.redis.cluster.max.total.retries.duration=10000
#jnosql.redis.cluster.ssl=false
#jnosql.redis.cluster.timeout=2000
#jnosql.redis.cluster.connection.timeout=2000
#jnosql.redis.cluster.socket.timeout=2000
----

==== Single Node Configuration

This API provides the `RedisConfigurations` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="2,2", options="header"]
|===
|Configuration property |Description

|`jnosql.redis.host` |The database host
|`jnosql.redis.port` |The database port
|`jnosql.redis.timeout` |The redis timeout, the default value is 2000 milliseconds
|`jnosql.redis.password` |The password's credential
|`jnosql.redis.database` |The redis database number
|`jnosql.redis.client.name` |The cluster client's name. The default value is 0.
|`jnosql.redis.max.total` |The value for the maxTotal configuration attribute for pools created with this configuration instance. The default value is 1000.
|`jnosql.redis.max.idle` |The value for the maxIdle configuration attribute for pools created with this configuration instance. The default value is 10.
|`jnosql.redis.min.idle` |The value for the minIdle configuration attribute for pools created with this configuration instance. The default value is 1.
|`jnosql.redis.max.wait.millis` |The value for the maxWait configuration attribute for pools created with this configuration instance. The default value is 3000 milliseconds.
|`jnosql.redis.connection.timeout` |The connection timeout in milliseconds configuration attribute for the jedis client configuration created with this configuration instance.
|`jnosql.redis.socket.timeout` |The socket timeout in milliseconds configuration attribute for the jedis client configuration with this configuration instance.
|`jnosql.redis.user` |The user configuration attribute for the jedis client configuration with this configuration instance.
|`jnosql.redis.ssl` |The ssl configuration attribute for the jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.protocol` |The protocol configuration attribute for the jedis client configuration with this configuration instance.
|`jnosql.redis.clientset.info.config.disabled` |The clientset info disabled configuration attribute for the jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.clientset.info.config.libname.suffix` |The clientset info configuration libname suffix attribute for the jedis client configuration with this configuration instance.
|===

==== Redis Sentinel Configuration

This API provides the `RedisSentinelConfigurations` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="2,2", options="header"]
|===
|Configuration Property |Description

|`jnosql.redis.sentinel.hosts` |The value for the sentinel HOST:PORT (separated by comma) configuration attribute for the jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.master.name` |The value for the master name configuration attribute for the jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.master.client.name` |The master client's name, the default value is 0
|`jnosql.redis.sentinel.slave.client.name` |The slave client's name, the default value is 0
|`jnosql.redis.sentinel.master.timeout` |The master redis timeout, the default value is 2000 milliseconds
|`jnosql.redis.sentinel.slave.timeout` |The slave redis timeout, the default value is 2000 milliseconds
|`jnosql.redis.sentinel.master.connection.timeout` |The connection timeout in milliseconds configuration attribute for the master jedis client configuration created with this configuration instance.
|`jnosql.redis.sentinel.slave.connection.timeout` |The connection timeout in milliseconds configuration attribute for the slave jedis client configuration created with this configuration instance.
|`jnosql.redis.sentinel.master.socket.timeout` |The socket timeout in milliseconds configuration attribute for the master jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.slave.socket.timeout` |The socket timeout in milliseconds configuration attribute for the slave jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.master.user` |The user configuration attribute for the master jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.slave.user` |The user configuration attribute for the slave jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.master.password` |The password configuration attribute for the master jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.slave.password` |The password configuration attribute for the slave jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.master.ssl` |The ssl configuration attribute for the master jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.sentinel.slave.ssl` |The ssl configuration attribute for the slave jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.sentinel.master.protocol` |The protocol configuration attribute for the master jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.slave.protocol` |The protocol configuration attribute for the slave jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.master.clientset.info.config.disabled` |The clientset info disabled configuration attribute for the master jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.sentinel.slave.clientset.info.config.disabled` |The clientset info disabled configuration attribute for the slave jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.sentinel.master.clientset.info.config.libname.suffix` |The clientset info configuration libname suffix attribute for the master jedis client configuration with this configuration instance.
|`jnosql.redis.sentinel.slave.clientset.info.config.libname.suffix` |The clientset info configuration libname suffix attribute for the slave jedis client configuration with this configuration instance.
|===

==== Redis Cluster Configuration

This API provides the `RedisClusterConfigurations` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="2,2", options="header"]
|===
|Configuration Property |Description

|`jnosql.redis.cluster.hosts` |The value for the sentinel HOST:PORT (separated by comma) configuration attribute for the jedis client configuration with this configuration instance.
|`jnosql.redis.cluster.client.name` |The cluster client's name. The default value is 0.
|`jnosql.redis.cluster.timeout` |The cluster redis timeout, the default value is 2000 milliseconds
|`jnosql.redis.cluster.connection.timeout` |The connection timeout in milliseconds configuration attribute for the cluster jedis client configuration created with this configuration instance.
|`jnosql.redis.cluster.socket.timeout` |The socket timeout in milliseconds configuration attribute for the cluster jedis client configuration with this configuration instance.
|`jnosql.redis.cluster.user` |The user configuration attribute for the cluster jedis client configuration with this configuration instance.
|`jnosql.redis.cluster.password` |The password configuration attribute for the cluster jedis client configuration with this configuration instance.
|`jnosql.redis.cluster.ssl` |The ssl configuration attribute for the cluster jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.cluster.protocol` |The protocol configuration attribute for the cluster jedis client configuration with this configuration instance.
|`jnosql.redis.cluster.clientset.info.config.disabled` |The clientset info disabled configuration attribute for the cluster jedis client configuration with this configuration instance. The default value is false.
|`jnosql.redis.cluster.clientset.info.config.libname.suffix` |The clientset info configuration libname suffix attribute for the cluster jedis client configuration with this configuration instance.
|`jnosql.redis.cluster.max.attempts` |The value for the max attempts configuration attribute for the cluster jedis client configuration with this configuration instance. Default is 5.
|`jnosql.redis.cluster.max.total.retries.duration` |The value for the max total retries configuration attribute for the cluster jedis client configuration with this configuration instance. Default is 10000 milliseconds.
|===

=== RedisBucketManagerFactory

The ```RedisBucketManagerFactory``` is a specialization of the ```BucketManagerFactory``` that enables ranking and counter feature.

[source,java]
----
@Inject
RedisBucketManagerFactory factory;
...
SortedSet game = factory.getSortedSet("game");
game.add("Otavio", 10);
game.add("Luiz", 20);
game.add("Ada", 30);
game.add(Ranking.of("Poliana", 40));

List<Ranking> ranking = game.getRanking();

Counter home = factory.getCounter("home");
Counter products = factory.getCounter("products");
home.increment();
products.increment();
products.increment(3L);
----

Using the same principle of the API you can inject using the `@KeyValueDatabase` qualifier.

[source,java]
----
@Inject
@KeyValueDatabase("counter")
Counter counter;

@Inject
@KeyValueDatabase("game")
SortedSet game;
----
== Riak

image::https://jnosql.github.io/img/logos/riak.png[Riak Project,align="center" width=25%,height=25%]

https://riak.com/[Riak] (pronounced "ree-ack") is a distributed NoSQL key-value data store that offers high availability, fault tolerance, operational simplicity, and scalability.
In addition to the open-source version, it comes in a supported enterprise version and a cloud storage version.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-redis</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```RiakConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Riak"]
|===
|Configuration property |Description

|`jnosql.riak.host`
|The database host

|===

This is an example using Riak's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.riak.communication.RiakKeyValueConfiguration
jnosql.keyvalue.database=heroes
----

== Solr

image::https://jnosql.github.io/img/logos/solr.svg[Apache Solr Project,align="center" width=25%,height=25%"]

https://solr.apache.org/[Solr] is an open-source enterprise-search platform, written in Java, from the Apache Lucene project.
Its major features include full-text search, hit highlighting, faceted search, real-time indexing, dynamic clustering, database integration, NoSQL features and rich document (e.g., Word, PDF) handling.
Providing distributed search and index replication, Solr is designed for scalability and fault tolerance.
Solr is widely used for enterprise search and analytics use cases and has an active development community and regular releases.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-solr</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the ```SolrDocumentConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Solr"]
|===
|Configuration property |Description

|`jnosql.solr.host`
|Database's host. E.g.: jnosql.solr.host=http://localhost:8983/solr/

|`jnosql.solr.user`
|The user's userID.

|`jnosql.solr.password`
|The user's password

|`jnosql.solr.automatic.commit`
|Define if each operation Apache Solr will commit automatically, true by default.

|===

This is an example using Solr's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.solr.communication.SolrDocumentConfiguration
jnosql.document.database=heroes
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<SolrDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<SolrDocumentManager> {

    @Produces
    public SolrDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        SolrDocumentConfiguration configuration = new SolrDocumentConfiguration();
        SolrDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```SolrRepository``` interface is an extension of the ```Repository``` interface that allows using Solr query annotation that executes Solr query.

[source,java]
----
@Repository
interface PersonRepository extends SolrRepository<Person, String> {

    @Solr("select * from Person")
    List<Person> findAll();

    @Solr("select * from Person where name = $name")
    List<Person> findByName(@Param("name") String name);
}
----

=== Template

The ```SolrTemplate``` interface is a specialization of the ```DocumentTemplate``` that allows execution of a Solr query.

[source,java]
----
@Inject
SolrTemplate template;
...
List<Person> people = template.solr("age:@age AND type:@type AND _entity:@entity", params);
----

== Neo4J

image::https://jnosql.github.io/img/logos/neo4j.png[Neo4J Project,align="center",width=25%,height=25%]
https://neo4j.com/[Neo4J] is a highly scalable, native graph database designed to manage complex relationships in data. It enables developers to build applications that leverage the power of graph traversal, pattern matching, and high-performance querying using the **Cypher** query language.

This API provides support for **Graph** database operations, including entity persistence, query execution via Cypher, and relationship traversal.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-neo4j</artifactId>
    <version>1.1.9</version>
</dependency>
----

=== Configuration

This API provides the `Neo4JDatabaseConfigurations` class to programmatically establish the credentials. You can configure Neo4J properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="2,4"]
|===
| Configuration Property | Description

| `jnosql.neo4j.uri` | The connection URI for the Neo4J database. Example: `bolt://localhost:7687`
| `jnosql.neo4j.username` | The username for authentication.
| `jnosql.neo4j.password` | The password for authentication.
| `jnosql.neo4j.database` | The target database name.
|===

==== Example Using MicroProfile Config

[source,properties]
----
jnosql.neo4j.uri=bolt://localhost:7687
jnosql.neo4j.username=neo4j
jnosql.neo4j.password=yourpassword
jnosql.neo4j.database=neo4j
----

=== Template API

The `Neo4JTemplate` interface extends `GraphTemplate` and allows for dynamic Cypher execution.

[source,java]
----
@Inject
private Neo4JTemplate template;

List<Person> people = template.cypherQuery("MATCH (p:Person) WHERE p.name = $name RETURN p", params);
var edge = template.edge(otavio, "FRIENDS_WITH", ada);
----

=== Repository Support

The `Neo4JRepository` interface extends the `NoSQLRepository` interface and enables query execution using the `@Cypher` annotation.

[source,java]
----
@Repository
interface PersonRepository extends Neo4JRepository<Person, String> {

    @Cypher("MATCH (p:Person) RETURN p")
    List<Person> findAll();

    @Cypher("MATCH (p:Person) WHERE p.name = $name RETURN p")
    List<Person> findByName(@Param("name") String name);
}
----


== Graph (Apache Tinkerpop)

Currently, the Jakarta NoSQL doesn't define an API for Graph database types but Eclipse JNoSQL provides a Graph template to explore the specific behavior of this NoSQL type.

Eclipse JNoSQL offers a mapping implementation for Graph NoSQL types:

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.databases</groupId>
    <artifactId>jnosql-tinkerpop</artifactId>
      <version>1.1.9</version>
</dependency>
----

Despite the other three NoSQL types, Eclipse JNoSQL API does not offer a communication layer for Graph NoSQL types. Instead, it integrates with https://tinkerpop.apache.org/[Apache Tinkerpop 3.x].

[source,java]
----
@Inject
TinkerpopTemplate template;
...

Category java = Category.of("Java");
Book effectiveJava = Book.of("Effective Java");

template.insert(java);
template.insert(effectiveJava);
EdgeEntity edge = template.edge(java, "is", software);

Stream<Book> books = template.getTraversalVertex()
        .hasLabel("Category")
        .has("name", "Java")
        .in("is")
        .hasLabel("Book")
        .getResult();
----

Apache TinkerPop is database agnostic. Thus, you can change the database in your application with no or minimal impact on source code.

You can define the database settings using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification, so you can add properties and overwrite it in the environment following the https://12factor.net/config[Twelve-Factor App].

[source,properties]
----
jnosql.graph.tinkerpop.provider=<CLASS-DRIVER>
jnosql.provider.host=<HOST>
jnosql.provider.user=<USER>
jnosql.provider.password=<PASSWORD>
----

TIP: The ```jnosql.graph.provider``` property is necessary when you have more than one driver in the classpath. Otherwise, it will take the first one.

These configuration settings are the default behavior. Nevertheless, there is an option to programmatically configure these settings. Create a class that implements the ```Supplier<Graph>```, then define it using the ```@Alternative``` and ```@Priority``` annotations.

[source,java]
----
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<Graph> {

    @Produces
    public Graph get() {
        Graph graph = ...; // from a provider
        return graph;
    }
}
----

You can work with several document database instances through CDI qualifier. To identify each database instance, make a `Graph` visible for CDI by putting the ```@Produces``` and the ```@Database``` annotations in the method.

[source,java]
----
@Inject
@Database(value = DatabaseType.GRAPH, provider = "databaseA")
private GraphTemplate templateA;

@Inject
@Database(value = DatabaseType.GRAPH, provider = "databaseB")
private GraphTemplate templateB;

// producers methods
@Produces
@Database(value = DatabaseType.GRAPH, provider = "databaseA")
public Graph getManagerA() {
    return manager;
}

@Produces
@Database(value = DatabaseType.GRAPH, provider = "databaseB")
public Graph getManagerB() {
    return manager;
}
----


Eclipse JNoSQL does not provide https://mvnrepository.com/artifact/org.apache.tinkerpop/gremlin-core[Apache Tinkerpop 3 dependency]; check if the provider does. Otherwise, do it manually.

[source,xml]
----
<dependency>
    <groupId>org.apache.tinkerpop</groupId>
    <artifactId>jnosql-gremlin-core</artifactId>
    <version>${tinkerpop.version}</version>
</dependency>
<dependency>
    <groupId>org.apache.tinkerpop</groupId>
    <artifactId>jnosql-gremlin-groovy</artifactId>
    <version>${tinkerpop.version}</version>
</dependency>
----

== Getting Help

Having trouble with Eclipse JNoSQL databases? We’d love to help!

Please report any bugs, concerns or questions with Eclipse JNoSQL databases to https://github.com/eclipse/jnosql[https://github.com/eclipse/jnosql].
Follow the instructions in the templates and remember to mention that the issue refers to JNoSQL databases.

== Contributing

We are very happy you are interested in helping us and there are plenty ways you can do so.

- https://github.com/eclipse/jnosql/issues[**Open an Issue:**]  Recommend improvements, changes and report bugs. Please, mention that the issue refers to the JNoSQL databases project.

- **Open a Pull Request:** If you feel like you can even make changes to our source code and suggest them, just check out our link:CONTRIBUTING.adoc[contributing guide] to learn about the development process, how to suggest bugfixes and improvements.

== Integration tests

The integration tests on databases primarily integrate with the https://www.testcontainers.org/[Testcontainers], requiring a more powerful computer.

Those tests are disabled by default; thus, if you want to run only the integration tests:

[source,bash]
----
mvn test -Djnosql.test.integration=true
----

To create integration tests on this project, we're using EnabledIfSystemProperty from JUnit Jupiter, where the system property is: `jnosql.test.integration`, and we expected `true` to execute.

We, the `IntegrationTest` structure class, hold this content, considering using it on the new integration tests.

[source,java]
----
import static org.eclipse.jnosql.communication.driver.IntegrationTest.NAMED;
import static org.eclipse.jnosql.communication.driver.IntegrationTest.MATCHES;

@EnabledIfSystemProperty(named = NAMED, matches = MATCHES)
class IntegrationSampleTest {

}
----

== Performing the Jakarta NoSQL TCK

To perform the Jakarta NoSQL TCK you should activate the `tck` profile. This profile will download the TCK and run it.


[source,bash]
----
mvn test -Ptck
----

To run the Jakarta NoSQL TCK only in a specific module, you can use the `-pl` option, for example:

[source,bash]
----
mvn test -Ptck -pl jnosql-mongodb
----


[IMPORTANT]
====
By default, activating the `tck` profile does not disable the execution of the default tests. To skip the default tests you can use `-DskipTests`. It will skip the unit tests and run only the TCK tests.
[source,bash]
----
mvn test -Ptck -DskipTests
----
====

The JNoSQL Database API implementations that support Jakarta NoSQL TCK execution already:

- link:#_mongodb[MongoDB]


== Want to Contribute a New Driver?

As an open-source project, you're free to create any driver, and you're welcome to join and participate in the process.
To add a new driver, we have a few requirements:

* Run Java 17
* Include the documentation driver in the README file.
* Cover the driver with tests and preferences with TestContainer.
* Please pay attention to the documentation. This includes JavaDoc
* Include a class to represent and contain the properties. In general, those are `enum`
** A nomenclature is the <DATABASE>Configurations, e.g., CassandraConfigurations, MongoDBConfigurations.
** The package name will follow the terminology: `org.jnosql.databases.[DATABASE].[LAYER]`
*** E.g., Give a database called "Ada" that is a column type, the package name will be: `org.eclipse.jnosql.databases.ada.communication` for the driver layer and `org.eclipse.jnosql.databases.ada.mapping` for the mapping.
*** You can include the database in a single project if a NoSQL supports multiple database types.
* It is crucial to have an integration test with the database; please annotate those `EnabledIfSystemProperty` and check the integration session to know more.
* Create a `Supplier` class on the mapping layer that will produce a specific Manager instance using Microprofile. Check: `ColumnManagerSupplier`, `DocumentManagerSupplier` classes to get more information.



== Graph Drivers

Eclipse JNoSQL uses https://tinkerpop.apache.org/[Apache Tinkerpop] for Graph API.
Using this API gives support to https://tinkerpop.apache.org/providers.html[over twenty fives databases].
